# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

CardStudio is a comprehensive **digital souvenir and exhibition platform** that creates interactive experiences for museums, tourist attractions, and cultural sites. The platform enables institutions to provide visitors with rich, AI-powered digital content accessible through QR codes on physical souvenir cards, offering detailed explanations, guidance, and multimedia experiences about exhibits, artifacts, and locations.

### Business Model & Architecture

**Three-Tier Ecosystem:**
1.  **Card Issuers** (B2B) - Museums, exhibitions, tourist attractions creating digital souvenir experiences ($2/card)
2.  **Administrators** (Platform) - CardStudio operators managing verifications and operations
3.  **Visitors** (B2C) - Tourists and museum guests scanning QR codes for free digital content and AI guidance

**Core Value Proposition:**
-   **Interactive Digital Souvenirs**: Physical cards with QR codes link to rich multimedia content about exhibits and locations.
-   **Credit-Based System**: Institutions purchase credits (1 credit = $1 USD) and consume 2 credits per card when creating batches.
-   **Advanced AI Voice Conversations**: Real-time voice-based AI using OpenAI Realtime API for natural conversations about exhibits.
-   **Multi-Language Support**: AI guidance available in 10 languages.
-   **Professional Souvenir Printing**: High-quality physical souvenir cards with global shipping.

### Target Markets
-   Museums & Art Galleries
-   Tourist Attractions & Landmarks
-   Cultural Heritage Sites
-   Exhibition Centers & Trade Shows
-   Theme Parks & Entertainment Venues

## Core Architecture

### Frontend Stack
-   **Vue 3** with Composition API and TypeScript
-   **PrimeVue 4** for UI components
-   **Pinia** for state management
-   **Vue Router** for navigation
-   **Tailwind CSS** for styling
-   **Vite** for build tooling

### Backend Stack
-   **Supabase**: PostgreSQL database, Auth, Storage, and Edge Functions.
-   **Stored Procedures**: All database operations are handled via `supabase.rpc()` calls to stored procedures in `sql/storeproc/`. Direct table access is disabled.
-   **Stripe**: Integrated for payments via Edge Functions.
-   **OpenAI Realtime API**: Integrated via **WebRTC** for direct, low-latency voice conversations.
-   **Ephemeral Tokens**: Secure, short-lived tokens for OpenAI connections, generated by a Supabase Edge Function.

## Setup and Development

### Prerequisites
- Node.js (v18+)
- Supabase CLI (`npm install -g supabase`)
- Stripe CLI (for webhook testing)
- OpenAI API key
- Stripe secret key

### Local Development Setup

1. **Clone and Install Frontend Dependencies**
   ```bash
   git clone <repo-url>
   cd Cardy
   npm install
   ```

2. **Configure Environment Variables**
   - Copy `.env.example` to `.env.local`
   - Set `VITE_SUPABASE_URL` and `VITE_SUPABASE_ANON_KEY` for your Supabase project
   - For local Supabase, use `http://localhost:54321` and your local anon key

3. **Start Local Supabase**
   ```bash
   supabase start
   # Note the local URL and keys from the output
   # Update .env.local with local values
   ```

4. **Generate Supabase Types**
   ```bash
   supabase gen types typescript --local > src/types/supabase.ts
   ```

5. **Run Frontend Development Server**
   ```bash
   npm run dev:local  # For local Supabase
   # or
   npm run dev        # For remote Supabase
   ```

6. **Serve Edge Functions Locally**
   ```bash
   npx supabase functions serve
   ```

### Database Setup

For local development, Supabase migrations run automatically on `supabase start`.

For production deployment:
1. Combine stored procedures: `./scripts/combine-storeproc.sh`
2. Navigate to Supabase Dashboard > SQL Editor
3. Execute `sql/schema.sql`
4. Execute `sql/all_stored_procedures.sql`
5. Execute `sql/policy.sql`
6. Execute `sql/triggers.sql`

**Database Update Workflow:**

When database schema or stored procedures need updates:

1. **Edit Source Files**:
   - Modify `sql/schema.sql` for all schema changes (tables, enums, indexes, including credit system)
   - Modify files in `sql/storeproc/client-side/` for client procedures
   - Modify files in `sql/storeproc/server-side/` for server procedures

2. **Generate Combined File**:
   - Run `./scripts/combine-storeproc.sh`
   - This generates/updates `sql/all_stored_procedures.sql` from individual files

3. **Manual Deployment** (user responsibility):
   - Copy SQL from modified files
   - Execute in Supabase Dashboard > SQL Editor
   - Execute files in order:
     1. `sql/schema.sql` (includes credit system tables)
     2. `sql/all_stored_procedures.sql`
     3. `sql/policy.sql`
     4. `sql/triggers.sql`
   - No migration scripts needed - manual deployment only

**Note**: `sql/all_stored_procedures.sql` is a GENERATED file. Always edit the source files in `sql/storeproc/`, not the generated file.

## Key Commands

```bash
# Frontend Development
npm run dev                 # Start development server (uses .env.local)
npm run dev:local           # Start local development server
npm run build               # Build for production
npm run build:production    # Build for production with production env
npm run type-check          # Run TypeScript type checking
npm run preview             # Preview production build

# Database Operations
supabase start              # Start local Supabase
supabase stop               # Stop local Supabase
supabase db reset           # Reset local database (runs migrations)
supabase gen types typescript --local > src/types/supabase.ts  # Generate TypeScript types

# Database Deployment (Manual via Supabase Dashboard)
# When updating database schema or stored procedures:
# 1. Edit source files in sql/schema.sql or sql/storeproc/
# 2. Run: ./scripts/combine-storeproc.sh (generates all_stored_procedures.sql)
# 3. Navigate to Supabase Dashboard > SQL Editor
# 4. Manually copy and execute SQL files in order:
#    - sql/schema.sql (includes credit system tables)
#    - sql/all_stored_procedures.sql
#    - sql/policy.sql
#    - sql/triggers.sql

# Edge Functions
npx supabase functions serve                    # Run all functions locally
npx supabase functions serve <function-name>    # Run specific function locally

# Edge Function Secrets (Production - set BEFORE deployment)
./scripts/setup-production-secrets.sh           # Interactive setup script
# Or manually:
npx supabase secrets set OPENAI_API_KEY=sk-...
npx supabase secrets set STRIPE_SECRET_KEY=sk_live_...
npx supabase secrets set OPENAI_REALTIME_MODEL=gpt-realtime-mini-2025-10-06

# Edge Function Deployment (AFTER secrets are set)
./scripts/deploy-edge-functions.sh              # Deploy all functions at once
npx supabase functions deploy <function-name>   # Deploy specific function

# View Edge Function Logs
npx supabase functions logs <function-name>     # View logs for specific function
npx supabase functions logs <function-name> --follow  # Stream logs in real-time
```

## Project Structure

```
Cardy/
├── public/                 # Static assets
├── src/
│   ├── assets/             # Images, CSS
│   ├── components/         # Reusable Vue components
│   │   ├── Admin/          # Admin-specific: AdminCardContent.vue, AdminCardDetailPanel.vue, etc.
│   │   ├── Card/           # Card management: CardDetailPanel.vue, CardListPanel.vue, ImportExport.vue
│   │   ├── CardComponents/ # Core card UI: Card.vue, CardAccessQR.vue, CardCreateEditForm.vue
│   │   ├── CardContent/    # Content editing: CardContent.vue, CardContentCreateEditForm.vue
│   │   ├── Layout/         # Layouts: AppHeader.vue, PageWrapper.vue
│   │   ├── DashboardLanguageSelector.vue
│   │   ├── ImageCropper.vue
│   │   └── ...             # Other: EmptyState.vue, MyDialog.vue, etc.
│   ├── layouts/            # Page layouts: AppLayout.vue, Dashboard.vue
│   ├── lib/                # Utilities: supabase.ts
│   ├── stores/             # Pinia stores
│   │   ├── admin/          # Admin stores: auditLog.ts, batches.ts, dashboard.ts, etc.
│   │   ├── auth.ts         # Authentication
│   │   ├── card.ts         # Card management
│   │   ├── language.ts     # Language (mobile & dashboard)
│   │   └── ...             # Others: contentItem.ts, issuedCard.ts, publicCard.ts
│   ├── utils/              # Helper functions: cardConfig.ts, imageUtils.js, stripeCheckout.js, etc.
│   ├── views/              # Page views
│   │   ├── Dashboard/      # Web dashboard
│   │   │   ├── Admin/      # Admin pages: AdminDashboard.vue, BatchManagement.vue, UserManagement.vue, etc.
│   │   │   └── CardIssuer/ # Issuer pages: MyCards.vue
│   │   │   ├── SignIn.vue, SignUp.vue, ResetPassword.vue
│   │   └── MobileClient/   # Mobile QR experience
│   │       ├── PublicCardView.vue  # Main mobile entry
│   │       └── components/
│   │           ├── MobileHeader.vue
│   │           ├── CardOverview.vue
│   │           ├── ContentList.vue
│   │           ├── ContentDetail.vue
│   │           ├── LanguageSelector.vue, LanguageSelectorModal.vue
│   │           └── AIAssistant/     # AI chat system
│   │               ├── MobileAIAssistant.vue
│   │               ├── components/  # UI: AIAssistantModal.vue, ChatInterface.vue, RealtimeInterface.vue
│   │               ├── composables/ # Logic: useChatCompletion.ts, useRealtimeConnection.ts, useVoiceRecording.ts, useWebRTCConnection.ts
│   │               └── types/       # Types
│   ├── i18n/               # Internationalization: locales/en.json (10 languages), index.ts
│   ├── router/             # Vue Router: index.ts with guards for auth/roles
│   └── main.ts             # App entry
├── sql/                    # Database
│   ├── schema.sql          # Tables, enums, indexes (including credit system)
│   ├── all_stored_procedures.sql  # GENERATED - All RPC functions (do not edit directly)
│   ├── storeproc/          # Source files:
│   │   ├── client-side/    # Auth, card, content, credit management, admin functions
│   │   └── server-side/    # Payment processing, credit purchase completion
│   ├── policy.sql          # RLS policies
│   ├── triggers.sql        # Triggers
│   └── migrations/         # Versioned changes (for reference)
├── supabase/               # Supabase config
│   ├── config.toml
│   └── functions/          # Edge Functions (Deno)
│       ├── _shared/        # CORS utils
│       ├── chat-with-audio/  # Voice/text chat (STT + response)
│       ├── chat-with-audio-stream/  # Streaming text responses
│       ├── create-checkout-session/  # Stripe checkout (legacy batch payment)
│       ├── create-credit-checkout-session/  # Stripe credit purchase
│       ├── generate-tts-audio/  # Text-to-Speech
│       ├── handle-checkout-success/  # Stripe webhook (legacy)
│       ├── handle-credit-purchase-success/  # Credit purchase completion
│       ├── stripe-credit-webhook/  # Credit system webhook
│       └── openai-realtime-token/  # WebRTC ephemeral tokens
├── scripts/                # Utility scripts
│   ├── combine-storeproc.sh        # Combine stored procedures into single file
│   ├── setup-production-secrets.sh # Interactive production secrets setup
│   ├── deploy-edge-functions.sh    # Deploy all Edge Functions at once
│   └── check-functions.sh          # Validate Edge Functions before deploy
├── .env.example            # Env template
├── package.json            # Dependencies: Vue, PrimeVue, Supabase, Stripe, OpenAI integrations
└── ...                     # Config: tailwind.config.js, vite.config.ts, tsconfig.json
```

## Components Explanation

### Dashboard Components (Web)
- **AppHeader.vue**: Navigation bar with user menu, role-based items (admin vs cardIssuer), language selector.
- **MyCards.vue**: Card issuer dashboard listing cards, create/edit/delete actions.
- **AdminDashboard.vue**: Admin overview with metrics, links to management pages.
- **BatchManagement.vue**: Admin batch issuance, payment tracking.
- **UserManagement.vue**: Admin user verification, role assignment.
- **CardCreateEditForm.vue**: Form for card creation/editing with image cropper, AI setup.
- **ImageCropper.vue**: Custom cropper for 2:3 aspect ratio cards.

### Mobile Client Components
- **PublicCardView.vue**: Orchestrates mobile flow: fetches card via RPC (`get_public_card_content` or `get_card_preview_content`), manages navigation stack (Overview -> List -> Detail).
- **MobileHeader.vue**: Back button, title, language selector.
- **CardOverview.vue**: Card hero image, description, explore button, language modal.
- **ContentList.vue**: Hierarchical content items, AI button if enabled.
- **ContentDetail.vue**: Item image, markdown content, sub-items list, AI assistant.
- **MobileAIAssistant.vue**: Wrapper for AI modal, toggles chat/realtime modes.

### AI Assistant Components
- **AIAssistantModal.vue**: Full-screen modal container.
- **ChatInterface.vue**: Text/voice chat UI, message bubbles, recording waveform, audio play.
- **RealtimeInterface.vue**: Live call UI with connection status, waveform, transcripts.
- **VoiceInputButton.vue**: Recording button with visual feedback.

### Composables (AI Logic)
- **useChatCompletion.ts**: Handles OpenAI Chat API calls via Edge Functions (`chat-with-audio`, `chat-with-audio-stream`), streaming, TTS via `generate-tts-audio`.
- **useWebRTCConnection.ts**: WebRTC peer connection setup, SDP negotiation, direct streaming to OpenAI via ephemeral tokens from `openai-realtime-token`.
- **useVoiceRecording.ts**: MediaRecorder for voice input, waveform visualization.
- **useCostSafeguards.ts**: Session limits, cost monitoring.
- **useInactivityTimer.ts**: Auto-disconnect on idle.

## Functionality Requirements

### Card Issuer Flow
1. **Registration**: Sign up, email verification, admin approval (role: 'cardIssuer').
2. **Credit Purchase**: Buy credits via Stripe (1 credit = $1 USD) through the Credit Management page (`/cms/credits`).
3. **Card Creation**: Upload image (crop to 2:3), set name/description, enable AI with instructions/knowledge base.
4. **Content Management**: Hierarchical items (exhibits > artifacts), markdown content, images, per-item AI knowledge.
5. **Batch Issuance**: 
   - **Credit-Based System** (Current): Navigate to card > Issue Batch dialog shows credit balance and required credits (2 credits/card)
   - If sufficient credits: Instant batch creation, cards generated immediately, no Stripe redirect
   - If insufficient credits: Dialog shows warning with "Purchase Credits" button redirecting to `/cms/credits`
   - Uses `issue_card_batch_with_credits()` stored procedure
   - Credits consumed atomically with batch creation (transaction-safe)
6. **Credit Management**: Monitor balance, view transaction history, purchase additional credits as needed.
7. **Print Requests**: After batch creation, optionally request physical card printing with shipping details.
8. **Analytics**: View engagement metrics per card/batch.

### Visitor (Mobile) Flow
1. **QR Scan**: Loads `PublicCardView` with issued card ID (or preview mode).
2. **Card Overview**: View card image/description, select language (10 options: en, zh-Hant (Traditional Chinese), zh-Hans (Simplified Chinese), ja, ko, es, fr, ru, ar, th).
3. **Content Navigation**: Browse top-level items, drill into details with sub-items.
4. **AI Interaction**:
   - **Chat Mode**: Text input or voice recording → Whisper STT → ChatGPT response → TTS audio.
   - **Realtime Mode**: Live voice call via WebRTC to OpenAI Realtime API, low-latency bidirectional audio.
   - Context: Combines card AI instruction, knowledge base, current content knowledge.
   - Language enforcement in prompts.

### Admin Flow
1. **User Management**: Verify businesses, assign roles ('admin' or 'cardIssuer').
2. **Credit Management**: Monitor all credit purchases, consumptions, and transactions. Adjust user credits for refunds or corrections.
   - **UI Pattern**: Follows Batch Management pattern (filters in table header, action buttons, dialogs)
   - **Action Buttons**: View Purchases, View Consumptions, View Transactions, Adjust Credits
   - **On-Demand Loading**: Dialog data fetched when opened, not preloaded
   - **Server-Side Operations**: All pagination, sorting, filtering done on server
   - **Search**: Debounced 500ms, searches by email or name
   - **Security**: Transaction locking prevents race conditions, negative balance prevented
3. **Batch Oversight**: Monitor issuances, credit consumption, print requests (statuses: pending, paid, shipped).
4. **Credit Statistics**: View system-wide credit metrics (circulation, revenue, consumption, pending).
5. **Audit Logs**: Track operations including credit transactions (via RPC logging).
6. **Content Moderation**: Review/approve cards.

### Payments & Credits
- **Credit System**: Users purchase credits upfront (1 credit = $1 USD) via Stripe checkout.
- **Batch Issuance**: 
  - **Credit-Based Flow** (Current): Consumes 2 credits per card, instant generation upon credit consumption
  - Uses `issue_card_batch_with_credits()` stored procedure which:
    - Checks credit balance via `check_credit_balance()`
    - Creates batch with `payment_method = 'credits'`, `payment_completed = true`
    - Consumes credits via `consume_credits_for_batch()`
    - Generates issued cards immediately
    - All operations atomic (rollback on failure)
  - UI Component: `CardIssuanceCheckout.vue` uses `useCreditStore().issueBatchWithCredits()`
  - No Stripe redirect during batch creation - credits must be purchased first
- **Stripe Integration**: Credit purchase checkout, webhooks for confirmation, automatic refund handling.
  - **Webhook Security**: Stripe webhook signature verification in Deno requires `stripe.webhooks.constructEventAsync()` (async version) due to Deno's async crypto environment. The webhook function disables JWT verification (`verify_jwt = false` in `config.toml`) but enforces Stripe signature verification.
- **Credit Management**: Real-time balance tracking, transaction history, consumption reports.
  - **Admin Interface**: `AdminCreditManagement.vue` for admin oversight
    - Statistics cards: Total circulation, revenue, purchased, consumed
    - User table: Paginated list with search by email/name (server-side, debounced 500ms)
    - Action buttons per user: View Purchases (green), View Consumptions (blue), View Transactions (gray), Adjust Credits (orange)
    - Dialogs: On-demand data loading, show user info + paginated tables
    - Adjust credits: Supports positive (add) or negative (deduct) with reason, prevents negative balance
  - **Card Issuer Interface**: `CreditManagement.vue` for users to manage their own credits
    - Balance overview: Current, purchased, consumed with monthly stats
    - Purchase dialog: Select amount (10-10,000 credits), Stripe checkout integration
    - Transaction history: Tabs for all transactions, purchases, consumptions
  - **Security**: Transaction locking (`FOR UPDATE`) prevents race conditions, all operations logged
  - **Audit Trail**: Every credit change recorded in `credit_transactions` with before/after balances
- **Print Requests**: Optional physical cards, status tracking, contact fields.

### Internationalization
- 10 languages via vue-i18n: English (en), Traditional Chinese (zh-Hant), Simplified Chinese (zh-Hans), Japanese (ja), Korean (ko), Spanish (es), French (fr), Russian (ru), Arabic (ar), Thai (th).
- Separate language stores: Mobile client uses `useMobileLanguageStore`, Dashboard uses `useDashboardLanguageStore`.
- Pluralization with pipe syntax (e.g., `{count} card | {count} cards`).
- RTL support for Arabic included in CSS.

## Deployment

### Frontend
1. Build: `npm run build`
2. Deploy `dist/` to static host (Vercel, Netlify, etc.).
3. Set env vars: `VITE_SUPABASE_URL`, `VITE_SUPABASE_ANON_KEY`.

### Backend (Supabase)
1. **Database**:
   - Combine stored procedures: `./scripts/combine-storeproc.sh`
   - Manually execute SQL files in Supabase Dashboard SQL Editor (in this exact order):
     1. `sql/schema.sql` (includes all tables and credit system)
     2. `sql/all_stored_procedures.sql` (generated from storeproc/ files)
     3. `sql/policy.sql` (RLS policies)
     4. `sql/triggers.sql` (database triggers)

2. **Edge Functions Secrets** (must be set before deployment):
   - Configure: `./scripts/setup-production-secrets.sh`
   - Or manually: `npx supabase secrets set OPENAI_API_KEY=sk-...`
   - Required: `OPENAI_API_KEY`, `STRIPE_SECRET_KEY`, `OPENAI_REALTIME_MODEL`

3. **Edge Functions Deployment**:
   - Deploy all: `./scripts/deploy-edge-functions.sh`
   - Or deploy individually: `npx supabase functions deploy <function-name>`

4. **Storage Policies**: Included in `sql/policy.sql` for images

### Production Notes
- **Deployment Order**: Database → Secrets → Edge Functions → Frontend
- Always set Edge Function secrets before deploying functions
- Use production env vars for frontend build
- Monitor Edge Function logs for API costs
- Test webhooks with Stripe CLI locally before production

## Notes and Best Practices

- **Database Access**: **NEVER** use `supabase.from()`. All database operations are handled via `supabase.rpc()` calling stored procedures (e.g., `get_public_card_content`, `create_card`, `update_content_item`). This pattern ensures security and centralizes business logic. Direct table access is prohibited.
- **Database Updates**: When updating stored procedures, edit source files in `sql/storeproc/`, run `./scripts/combine-storeproc.sh`, then manually execute the generated `sql/all_stored_procedures.sql` in Supabase Dashboard. Do NOT write migration scripts - user handles manual deployment.
- **Role Handling**: Supabase Auth with custom roles stored in `raw_user_meta_data.role`. Router guards check 'admin' vs 'cardIssuer'. After role changes, users must refresh their session to sync metadata.
- **Image Handling**: All cards use 2:3 aspect ratio. Images cropped via `vue-advanced-cropper`. Both original and cropped versions stored in Supabase Storage buckets. Crop parameters saved to enable re-cropping.
- **AI Costs**: Use `gpt-4o-mini` for chat mode, `gpt-realtime-mini-2025-10-06` for voice mode (realtime). Implement safeguards: session limits, inactivity timeouts, daily caps.
- **Error Handling**: Use PrimeVue Toast (`useToast`) for user feedback. Log errors to browser console and operations log (via stored procedures).
- **Component Size**: Keep <400 lines; extract to composables.
- **i18n**: Pipe syntax for plurals, no ICU. Update locales/en.json as base.
- **Markdown**: Render with `marked` library, sanitize for `v-html`.
- **Mobile Optimization**: Responsive Tailwind, touch-friendly, PWA-ready.
- **Edge Functions Authentication**: When Edge Functions need to validate user authentication:
  - Use service role client: `createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)`
  - Extract JWT token from Authorization header: `req.headers.get('Authorization').replace('Bearer ', '')`
  - Validate token: `supabaseAdmin.auth.getUser(token)` - this returns user info from the JWT
  - Pass `user.id` explicitly to stored procedures when using service role (since `auth.uid()` returns NULL with service role)
  - Stored procedures should accept optional `p_user_id` parameter: `COALESCE(p_user_id, auth.uid())`
- **Common Issues**:
  - Role mismatches: Refresh session to sync DB metadata.
  - Audio permissions: Handle gracefully in WebRTC/STT.
  - CORS: Edge functions handle via `_shared/cors.ts`.
  - Large images: Compress with `browser-image-compression`.
  - **Deno Stripe Webhooks**: Always use `stripe.webhooks.constructEventAsync()` (async version) for signature verification in Deno Edge Functions due to async crypto environment. Using the sync `constructEvent()` will fail.
  - **Edge Function 401 Errors**: If Edge Functions return 401 Unauthorized, check that JWT tokens are being properly validated. Don't use `getUser()` without parameters - always pass the token explicitly when using service role client.
  - **Edge Function Helper Functions**: In Deno Edge Functions, helper functions defined with `const` (function expressions) are not hoisted. Always define helper functions **before** they are called, or use function declarations (`function name() {}`) which are hoisted.
  - **Legacy Batch Payment vs Credit System**: 
    - **Current System** (Recommended): Credit-based batch issuance. Users purchase credits via `/cms/credits` → Use credits to create batches instantly via `CardIssuanceCheckout.vue` → No Stripe checkout during batch creation
    - **Legacy System** (Deprecated): Direct batch payment via `create-checkout-session` Edge Function. Still functional for backward compatibility but not recommended for new implementations
    - Migration: `CardIssuanceCheckout.vue` has been fully migrated to use `useCreditStore().issueBatchWithCredits()` instead of `createCheckoutSession()`
  - **Credit Adjustment Errors**: If credit adjustment fails, check for: (1) User has `user_credits` record (auto-created), (2) Adjustment doesn't result in negative balance, (3) Admin has proper role in metadata, (4) Amount is not zero.
  - **Admin Dialog Data**: When opening dialogs (purchases, consumptions, transactions), previous user's data may flash briefly. This is normal - new data loads on-demand when dialog opens.
  - **Search Performance**: For user bases >10,000, consider implementing full-text search (tsvector) instead of LIKE queries for better performance.
- **Testing**: Use local Supabase for dev, preview mode for unactivated cards.
- **Security**: RLS policies enforce public read-only for cards, auth for dashboard.
- **Performance**: Lazy-load routes, virtual scrolling for lists, WebRTC for low-latency AI.

For additional technical details, see files in `docs_archive/` (all implementation docs have been archived there).

## Consolidated documentation (scanned)

I scanned the repository's markdown documents and consolidated the most important operational and architecture notes below. If you want, I can archive the remaining files into `docs_archive/` (or delete them) — I will wait for your confirmation before moving or deleting files.

- **Real-time audio mode (REALTIME_MODE_FINAL_SUMMARY.md)**
  - Status: Implementation complete and deployed.
  - Key points: full WebRTC integration, ephemeral tokens, direct OpenAI connections (optional relay), UI/UX details (waveform, live transcript), performance metrics, testing checklist, and production readiness notes.
  - Action: Included core architecture, user flow, and deployment notes above (AI Infrastructure, Realtime Mode).

- **OpenAI Realy Server & setup (OPENAI_RELAY_IMPLEMENTATION_SUMMARY.md / OPENAI_RELAY_SERVER_SETUP.md)**
  - Purpose: Relay server to proxy OpenAI Realtime API for regions where direct access is blocked.
  - Contents: relay server architecture, deployment options (Railway, DigitalOcean, AWS, Cloud Run), security and scaling recommendations, testing steps, and environment configuration (VITE_OPENAI_RELAY_URL).
  - Action: Added relay overview to AI Infrastructure section. Keep `openai-relay-server/` directory (contains full server docs) if you intend to support blocked regions; otherwise archive it.

- **AI Assistant — 10 languages (AI_ASSISTANT_10_LANGUAGES.md)**
  - Purpose: Full design and implementation notes for supporting 10 languages (text + audio) including welcome messages, language selection, testing plan, and cost estimates.
  - Action: Core language list and welcome message guidance were integrated into the i18n and AI notes above.

- **Edge Functions configuration (EDGE_FUNCTIONS_CONFIG.md)**
  - Purpose: Centralized environment variable guidance for all Supabase Edge Functions (chat-with-audio, generate-tts-audio, create-checkout-session, etc.).
  - Action: Relevant secrets and deployment checklist have been summarized into the Setup & Deployment and Environment Variables sections above.

## Archived files (moved to `docs_archive/`)

I archived a curated set of implementation and deployment documents into `docs_archive/` to reduce clutter while preserving full content and git history. Originals were removed from the repository root and the archived copies are committed under `docs_archive/`.

Archived files (now in `docs_archive/`):

- `REALTIME_AUDIO_FULL_IMPLEMENTATION.md`
- `AI_STREAMING_IMPLEMENTATION.md`
- `AI_TEXT_TTS_IMPLEMENTATION.md`
- `AI_ASSISTANT_DEPLOYMENT_GUIDE.md`
- `AI_ASSISTANT_IMPLEMENTATION_COMPLETE.md`
- `AI_ASSISTANT_REVAMP.md`
- `AI_ASSISTANT_10_LANGUAGES.md`
- `EDGE_FUNCTIONS_CONFIG.md`
- `OPENAI_RELAY_IMPLEMENTATION_SUMMARY.md`
- `OPENAI_RELAY_SERVER_SETUP.md`
- `STREAMING_QUICK_START.md`

All implementation documentation has been consolidated and archived for reference.

## Deep archive summaries (high-level highlights extracted from `docs_archive/`)

- **Realtime & Relay**:
  - Realtime mode uses WebRTC + ephemeral tokens for low-latency voice (model: `gpt-realtime-mini-2025-10-06`). Direct WebRTC connection is used in production. Set `OPENAI_REALTIME_MODEL` in Supabase secrets. See `docs_archive/REALTIME_AUDIO_FULL_IMPLEMENTATION.md` for implementation details.

- **AI Assistant Modes**:
  - Two main modes: Chat Completion (text-first, cheaper) and Realtime (voice, low-latency). Recommended production flow: Text + TTS (STT → text generation → TTS) for cost/UX, plus text streaming (SSE) for faster perceived responses. See `docs_archive/AI_TEXT_TTS_IMPLEMENTATION.md` and `AI_STREAMING_IMPLEMENTATION.md`.

- **Edge Functions & Secrets**:
  - Central config in `supabase/config.toml` for local dev; use `supabase secrets set` in production. Required secrets: `OPENAI_API_KEY`, `STRIPE_SECRET_KEY`. Optional overrides: `OPENAI_AUDIO_MODEL`, `OPENAI_TTS_VOICE`, `OPENAI_MAX_TOKENS`, `OPENAI_AUDIO_FORMAT`. See `docs_archive/EDGE_FUNCTIONS_CONFIG.md`.

- **Internationalization (i18n)**:
  - Platform supports 10 languages: `en` (English), `zh-Hant` (Traditional Chinese), `zh-Hans` (Simplified Chinese), `ja` (Japanese), `ko` (Korean), `es` (Spanish), `fr` (French), `ru` (Russian), `ar` (Arabic), `th` (Thai). AI assistant provides localized welcome messages and RTL handling for Arabic. Keep mobile and dashboard language stores separate (`useMobileLanguageStore` and `useDashboardLanguageStore`). See `docs_archive/AI_ASSISTANT_10_LANGUAGES.md`.

- **Deployment & Ops**:
  - Frontend: `npm run build` → deploy `dist/`. Edge Functions: `npx supabase functions deploy`. Always set secrets before deploy, add monitoring (health, logs, metrics), run browser compatibility tests (Safari/iOS). See `docs_archive/AI_ASSISTANT_DEPLOYMENT_GUIDE.md` and `docs_archive/REALTIME_AUDIO_FULL_IMPLEMENTATION.md`.

- **Cost & Safeguards**:
  - Realtime voice sessions are costlier (~$0.90 per 5-min session) than chat/text. Implement session timeouts, daily caps, and cost-monitoring; default to Text+TTS for public usage. See archived cost analysis files.

- **Security & Best Practices**:
  - Use ephemeral tokens for realtime, rotate API keys, never commit secrets, enforce RLS and CORS, and use HTTPS/WSS in production. See `docs_archive/EDGE_FUNCTIONS_CONFIG.md` and relay docs.

- **Testing & Compatibility**:
  - Test on Chrome, Firefox, Safari (desktop + iOS) and mobile browsers; verify microphone permissions, audio autoplay policies, and graceful fallbacks (text-only mode).

- **Where to find full details**:
  - All archived docs are in `docs_archive/`. Use the file names listed earlier in this document to jump to full guides, checklists, scripts, and config examples.

---

Next steps (pick one):
- A: Archive additional files (specify filenames or patterns).
- B: Restore specific archived files back to repo root (specify filenames).
- C: Finalize and run a quick linter / smoke-check.