# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

CardStudio is a comprehensive **digital souvenir and exhibition platform** that creates interactive experiences for museums, tourist attractions, and cultural sites. The platform enables institutions to provide visitors with rich, AI-powered digital content accessible through QR codes on physical souvenir cards, offering detailed explanations, guidance, and multimedia experiences about exhibits, artifacts, and locations.

### Business Model & Architecture

**Three-Tier Ecosystem:**
1.  **Card Issuers** (B2B) - Museums, exhibitions, tourist attractions creating digital souvenir experiences ($2/card)
2.  **Administrators** (Platform) - CardStudio operators managing verifications and operations
3.  **Visitors** (B2C) - Tourists and museum guests scanning QR codes for free digital content and AI guidance

**Core Value Proposition:**
-   **Interactive Digital Souvenirs**: Physical cards with QR codes link to rich multimedia content about exhibits and locations.
-   **Credit-Based System**: Institutions purchase credits (1 credit = $1 USD) and consume 2 credits per card when creating batches, 1 credit per language for AI translations.
-   **Advanced AI Voice Conversations**: Real-time voice-based AI using OpenAI Realtime API for natural conversations about exhibits.
-   **Multi-Language Support**: AI guidance and content available in multiple languages with GPT-4.1-nano powered translations. **Active languages: English (en) and Traditional Chinese (zh-Hant)**.
-   **AI-Powered Translation**: One-click translation of card content to multiple languages using GPT-4.1-nano, with automatic outdated detection. 10 language options available but only en/zh-Hant actively maintained.
-   **Professional Souvenir Printing**: High-quality physical souvenir cards with global shipping.

### Target Markets
-   Museums & Art Galleries
-   Tourist Attractions & Landmarks
-   Cultural Heritage Sites
-   Exhibition Centers & Trade Shows
-   Theme Parks & Entertainment Venues

## Core Architecture

### Frontend Stack
-   **Vue 3** with Composition API and TypeScript
-   **PrimeVue 4** for UI components
-   **Pinia** for state management
-   **Vue Router** for navigation
-   **Tailwind CSS** for styling
-   **Vite** for build tooling

### Backend Stack
-   **Supabase**: PostgreSQL database, Auth, Storage, and Edge Functions.
-   **Stored Procedures**: All database operations are handled via `supabase.rpc()` calls to stored procedures in `sql/storeproc/`. Direct table access is disabled.
-   **Stripe**: Integrated for payments via Edge Functions.
-   **OpenAI Realtime API**: Integrated via **WebRTC** for direct, low-latency voice conversations.
-   **Ephemeral Tokens**: Secure, short-lived tokens for OpenAI connections, generated by a Supabase Edge Function.

## Setup and Development

### Prerequisites
- Node.js (v18+)
- Supabase CLI (`npm install -g supabase`)
- Stripe CLI (for webhook testing)
- OpenAI API key
- Stripe secret key

### Local Development Setup

1. **Clone and Install Frontend Dependencies**
   ```bash
   git clone <repo-url>
   cd Cardy
   npm install
   ```

2. **Configure Environment Variables**
   - Copy `.env.example` to `.env.local`
   - Set `VITE_SUPABASE_URL` and `VITE_SUPABASE_ANON_KEY` for your Supabase project
   - For local Supabase, use `http://localhost:54321` and your local anon key

3. **Start Local Supabase**
   ```bash
   supabase start
   # Note the local URL and keys from the output
   # Update .env.local with local values
   ```

4. **Generate Supabase Types**
   ```bash
   supabase gen types typescript --local > src/types/supabase.ts
   ```

5. **Run Frontend Development Server**
   ```bash
   npm run dev:local  # For local Supabase
   # or
   npm run dev        # For remote Supabase
   ```

6. **Serve Edge Functions Locally**
   ```bash
   npx supabase functions serve
   ```

### Database Setup

For local development, Supabase migrations run automatically on `supabase start`.

For production deployment:
1. Combine stored procedures: `./scripts/combine-storeproc.sh`
2. Navigate to Supabase Dashboard > SQL Editor
3. Execute `sql/schema.sql`
4. Execute `sql/all_stored_procedures.sql`
5. Execute `sql/policy.sql`
6. Execute `sql/triggers.sql`

**Database Update Workflow:**

When database schema or stored procedures need updates:

1. **Edit Source Files**:
   - Modify `sql/schema.sql` for all schema changes (tables, enums, indexes, including credit system)
   - Modify files in `sql/storeproc/client-side/` for client procedures
   - Modify files in `sql/storeproc/server-side/` for server procedures

2. **Generate Combined File**:
   - Run `./scripts/combine-storeproc.sh`
   - This generates/updates `sql/all_stored_procedures.sql` from individual files

3. **Manual Deployment** (user responsibility):
   - Copy SQL from modified files
   - Execute in Supabase Dashboard > SQL Editor
   - Execute files in order:
     1. `sql/schema.sql` (includes credit system tables)
     2. `sql/all_stored_procedures.sql`
     3. `sql/policy.sql`
     4. `sql/triggers.sql`
   - No migration scripts needed - manual deployment only

**Note**: `sql/all_stored_procedures.sql` is a GENERATED file. Always edit the source files in `sql/storeproc/`, not the generated file.

## Key Commands

```bash
# Frontend Development
npm run dev                 # Start development server (uses .env.local)
npm run dev:local           # Start local development server
npm run build               # Build for production
npm run build:production    # Build for production with production env
npm run type-check          # Run TypeScript type checking
npm run preview             # Preview production build

# Database Operations
supabase start              # Start local Supabase
supabase stop               # Stop local Supabase
supabase db reset           # Reset local database (runs migrations)
supabase gen types typescript --local > src/types/supabase.ts  # Generate TypeScript types

# Database Deployment (Manual via Supabase Dashboard)
# When updating database schema or stored procedures:
# 1. Edit source files in sql/schema.sql or sql/storeproc/
# 2. Run: ./scripts/combine-storeproc.sh (generates all_stored_procedures.sql)
# 3. Navigate to Supabase Dashboard > SQL Editor
# 4. Manually copy and execute SQL files in order:
#    - sql/schema.sql (includes credit system tables)
#    - sql/all_stored_procedures.sql
#    - sql/policy.sql
#    - sql/triggers.sql

# Edge Functions
npx supabase functions serve                    # Run all functions locally
npx supabase functions serve <function-name>    # Run specific function locally

# Edge Function Secrets (Production - set BEFORE deployment)
./scripts/setup-production-secrets.sh           # Interactive setup script
# Or manually:
npx supabase secrets set OPENAI_API_KEY=sk-...
npx supabase secrets set STRIPE_SECRET_KEY=sk_live_...
npx supabase secrets set OPENAI_REALTIME_MODEL=gpt-realtime-mini-2025-10-06

# Edge Function Deployment (AFTER secrets are set)
./scripts/deploy-edge-functions.sh              # Deploy all functions at once
npx supabase functions deploy <function-name>   # Deploy specific function

# View Edge Function Logs
npx supabase functions logs <function-name>     # View logs for specific function
npx supabase functions logs <function-name> --follow  # Stream logs in real-time
```

## Project Structure

```
Cardy/
├── public/                 # Static assets
├── src/
│   ├── assets/             # Images, CSS
│   ├── components/         # Reusable Vue components
│   │   ├── Admin/          # Admin-specific: AdminCardContent.vue, AdminCardDetailPanel.vue, etc.
│   │   ├── Card/           # Card management: CardDetailPanel.vue, CardListPanel.vue, ImportExport.vue
│   │   ├── CardComponents/ # Core card UI: Card.vue, CardAccessQR.vue, CardCreateEditForm.vue
│   │   ├── CardContent/    # Content editing: CardContent.vue, CardContentCreateEditForm.vue
│   │   ├── Layout/         # Layouts: UnifiedHeader.vue (shared header for landing/dashboard), PageWrapper.vue
│   │   ├── CreditConfirmationDialog.vue  # Reusable credit confirmation (see README)
│   │   ├── DashboardLanguageSelector.vue
│   │   ├── ImageCropper.vue
│   │   └── ...             # Other: EmptyState.vue, MyDialog.vue, etc.
│   ├── layouts/            # Page layouts: AppLayout.vue, Dashboard.vue
│   ├── lib/                # Utilities: supabase.ts
│   ├── stores/             # Pinia stores
│   │   ├── admin/          # Admin stores: auditLog.ts, batches.ts, dashboard.ts, etc.
│   │   ├── auth.ts         # Authentication
│   │   ├── card.ts         # Card management
│   │   ├── language.ts     # Language (mobile & dashboard)
│   │   └── ...             # Others: contentItem.ts, issuedCard.ts, publicCard.ts
│   ├── utils/              # Helper functions: cardConfig.ts, imageUtils.js, stripeCheckout.js, etc.
│   ├── views/              # Page views
│   │   ├── Dashboard/      # Web dashboard
│   │   │   ├── Admin/      # Admin pages: AdminDashboard.vue, BatchManagement.vue, UserManagement.vue, etc.
│   │   │   └── CardIssuer/ # Issuer pages: MyCards.vue
│   │   │   ├── SignIn.vue, SignUp.vue, ResetPassword.vue
│   │   └── MobileClient/   # Mobile QR experience
│   │       ├── PublicCardView.vue  # Main mobile entry
│   │       └── components/
│   │           ├── MobileHeader.vue
│   │           ├── CardOverview.vue
│   │           ├── ContentList.vue
│   │           ├── ContentDetail.vue
│   │           ├── LanguageSelector.vue, LanguageSelectorModal.vue
│   │           └── AIAssistant/     # AI chat system
│   │               ├── MobileAIAssistant.vue
│   │               ├── components/  # UI: AIAssistantModal.vue, ChatInterface.vue, RealtimeInterface.vue
│   │               ├── composables/ # Logic: useChatCompletion.ts, useRealtimeConnection.ts, useVoiceRecording.ts, useWebRTCConnection.ts
│   │               └── types/       # Types
│   ├── i18n/               # Internationalization: locales/en.json, zh-Hant.json (actively maintained), + 8 placeholder languages
│   ├── router/             # Vue Router: index.ts with guards for auth/roles
│   └── main.ts             # App entry
├── sql/                    # Database
│   ├── schema.sql          # Tables, enums, indexes (including credit system)
│   ├── all_stored_procedures.sql  # GENERATED - All RPC functions (do not edit directly)
│   ├── storeproc/          # Source files:
│   │   ├── client-side/    # Auth, card, content, credit management, admin functions
│   │   └── server-side/    # Payment processing, credit purchase completion
│   ├── policy.sql          # RLS policies
│   ├── triggers.sql        # Triggers
│   └── migrations/         # Versioned changes (for reference)
├── supabase/               # Supabase config
│   ├── config.toml
│   └── functions/          # Edge Functions (Deno)
│       ├── _shared/        # CORS utils
│       ├── chat-with-audio/  # Voice/text chat (STT + response)
│       ├── chat-with-audio-stream/  # Streaming text responses
│       ├── create-checkout-session/  # Stripe checkout (legacy batch payment)
│       ├── create-credit-checkout-session/  # Stripe credit purchase
│       ├── generate-tts-audio/  # Text-to-Speech
│       ├── handle-checkout-success/  # Stripe webhook (legacy)
│       ├── handle-credit-purchase-success/  # Credit purchase completion
│       ├── stripe-credit-webhook/  # Credit system webhook
│       ├── translate-card-content/  # AI-powered translation (GPT-4)
│       └── openai-realtime-token/  # WebRTC ephemeral tokens
├── scripts/                # Utility scripts
│   ├── combine-storeproc.sh        # Combine stored procedures into single file
│   ├── setup-production-secrets.sh # Interactive production secrets setup
│   ├── deploy-edge-functions.sh    # Deploy all Edge Functions at once
│   └── check-functions.sh          # Validate Edge Functions before deploy
├── .env.example            # Env template
├── package.json            # Dependencies: Vue, PrimeVue, Supabase, Stripe, OpenAI integrations
└── ...                     # Config: tailwind.config.js, vite.config.ts, tsconfig.json
```

## Components Explanation

### Dashboard Components (Web)
- **UnifiedHeader.vue**: Shared navigation bar for landing page and dashboard. In landing mode, shows navigation links + Sign In/Sign Up. In dashboard mode, shows user menu with role-based items (admin vs cardIssuer), credit balance, and language selector. Provides consistent branding across the platform.
- **MyCards.vue**: Card issuer dashboard listing cards, create/edit/delete actions. Manages URL parameters (cardId, tab, batchId) for deep linking.
- **AdminDashboard.vue**: Admin overview with metrics, links to management pages.
- **BatchManagement.vue**: Admin batch issuance, payment tracking.
- **UserManagement.vue**: Admin user verification, role assignment.
- **CardCreateEditForm.vue**: Form for card creation/editing with image cropper, AI setup, and **original language selector** (dropdown with flag emojis and tooltip explaining importance for AI translation).
- **CardView.vue**: Card detail viewer with **translation preview** functionality - displays card name/description in selected language with language dropdown selector.
- **CardContentView.vue**: Content item detail viewer with **translation preview** functionality - displays item name/content in selected language with language dropdown selector.
- **CardIssuanceCheckout.vue**: Batch creation with credit confirmation, success dialog, and navigation to Access tab with batchId.
- **CardAccessQR.vue**: QR code generation and management with **bulk download features**: Download all QR codes as ZIP file (with README), download CSV with card URLs. Supports URL-based batch filtering via batchId parameter.
- **CreditConfirmationDialog.vue**: Reusable dialog for credit usage confirmation with balance tracking and warnings (used by batch issuance and translation).
- **CardTranslationSection.vue**: Multi-language support section in General tab with **status indicators** (Original, Translated, Outdated counts), visual badges for language status, and "Manage Translations" button. Full-width layout for optimal information display.
- **TranslationDialog.vue**: Multi-step translation dialog with **smart status indicators** (up-to-date, outdated, not translated) using icons and tooltips, **credit confirmation integration** before translation, Step 1: Language selection, Step 2: Progress tracking, Step 3: Success confirmation.
- **ImageCropper.vue**: Custom cropper for 2:3 aspect ratio cards.

### Mobile Client Components
- **PublicCardView.vue**: Orchestrates mobile flow: fetches card via RPC (`get_public_card_content` or `get_card_preview_content`), manages navigation stack (Overview -> List -> Detail).
- **MobileHeader.vue**: Back button, title, language selector.
- **CardOverview.vue**: Card hero image, description, explore button, language modal.
- **ContentList.vue**: Hierarchical content items, AI button if enabled.
- **ContentDetail.vue**: Item image, markdown content, sub-items list, AI assistant.
- **MobileAIAssistant.vue**: Wrapper for AI modal, toggles chat/realtime modes.

### AI Assistant Components
- **AIAssistantModal.vue**: Full-screen modal container with header actions (clear chat, mode toggle, close).
- **ChatInterface.vue**: Text/voice chat UI, message bubbles, recording waveform, audio play.
- **RealtimeInterface.vue**: Live call UI with connection status, waveform, transcripts.
- **VoiceInputButton.vue**: Recording button with visual feedback.
- **Clear Chat Button**: Trash icon in modal header (chat mode only) to clear conversation history while keeping modal open.

### Composables (AI Logic)
- **useChatCompletion.ts**: Handles OpenAI Chat API calls via Edge Functions (`chat-with-audio`, `chat-with-audio-stream`), streaming, TTS via `generate-tts-audio`.
- **useWebRTCConnection.ts**: WebRTC peer connection setup, SDP negotiation, direct streaming to OpenAI via ephemeral tokens from `openai-realtime-token`.
- **useVoiceRecording.ts**: MediaRecorder for voice input, waveform visualization.
- **useCostSafeguards.ts**: Session limits, cost monitoring.
- **useInactivityTimer.ts**: Auto-disconnect on idle.

## Functionality Requirements

### Card Issuer Flow
1. **Registration**: Sign up, email verification, admin approval (role: 'cardIssuer').
2. **Credit Purchase**: Buy credits via Stripe (1 credit = $1 USD) through the Credit Management page (`/cms/credits`).
3. **Card Creation**: Upload image (crop to 2:3), set name/description, **select original language** (dropdown with language options, **actively maintained: en, zh-Hant**), enable AI with instructions/knowledge base.
4. **Content Management**: Hierarchical items (exhibits > artifacts), markdown content, images, per-item AI knowledge.
5. **Export/Import**: 
   - **Export**: Download cards as Excel files with embedded images and all content items. Preserves hierarchy, AI settings, crop parameters, translations, and content hashes in hidden columns.
   - **Import**: Upload Excel files to create/update cards. **1-step process** - translations and hashes preserved automatically! Supports bulk operations, validation preview, and automatic image processing.
   - **Complete Data Preservation**: Exports include `original_language`, `translations` JSONB, and `content_hash` in hidden Excel columns. Import restores everything in a single RPC call per entity.
   - **Template**: Download pre-formatted Excel template for easy card creation.
   - **Example**: Load pre-built museum card example to learn the format.
6. **Translation Management** (Integrated in General Tab):
   - **Access**: Navigate to card > General tab > Scroll to "Multi-Language Support" section
   - **Compact View**: Shows translation status summary:
     - Original language
     - Translated languages count (with up-to-date/outdated indicators)
     - Language tags with status badges
   - **Important Warnings** (shown before first translation):
     - Finish preparing all content first (card details + content items)
     - Each language costs 1 credit and covers entire card
     - Uses GPT-4.1-nano for high-quality museum & cultural content translation
   - **Translate Actions**: Click "Manage Translations" button to open dialog
   - **Translation Dialog**:
     - **Smart Status Indicators**: Languages marked as "Up to Date" (cannot re-translate), "Outdated" (update recommended), or "Not Translated" (available)
     - **Visual Cues**: Small icons with tooltips, color-coded borders (green for up-to-date, amber for outdated, gray for new)
     - **Credit Confirmation**: Shows confirmation dialog before translation with cost breakdown and balance check
     - Multi-select languages with quick filters (All, Popular, Outdated)
     - Real-time progress tracking
     - Success confirmation with credit summary
   - **Cost**: 1 credit per language per card (covers card name/description + all content item names/content)
   - **Process**: Uses GPT-4.1-nano for efficient, high-quality, context-aware translation preserving markdown
   - **Parallel Execution**: All selected languages translate **simultaneously** (not sequentially) for 3-10x speed improvement
   - **Note**: AI knowledge base remains in original language for consistency
   - **Limits**: Supports cards up to ~60,000 tokens (~45,000 words). Larger cards will receive an error message
   - **Performance** (with parallel translation):
     - **Single language**: ~30s (same as before)
     - **3 languages**: ~30s (was ~90s sequential) - **3x faster**
     - **5 languages**: ~30s (was ~150s sequential) - **5x faster**
     - **10 languages**: ~30-40s (was ~300s sequential) - **7-10x faster**
   - **Automatic Freshness Detection**: Content hash tracking marks translations as outdated when original edited
   - **Translation Storage**: JSONB columns with timestamps and hashes for version tracking
7. **Translation Preview**: 
   - **Card View**: Language dropdown in "Basic Information" section to preview translated card name and description
   - **Content View**: Language dropdown in content item details to preview translated item name and content
   - **Fallback**: If translation unavailable for selected language, displays original language content
   - **Use Case**: Review translations before publishing to visitors, verify translation quality
8. **Batch Issuance**: 
   - **Credit-Based System** (Current): Navigate to card > Issue Batch dialog shows credit balance and required credits (2 credits/card)
   - **Minimum Batch Size**: Configurable via `.env` variable `VITE_BATCH_MIN_QUANTITY` (default: 100 cards). Frontend validation with user feedback:
     - Input field accepts any positive number (no auto-correction to minimum)
     - Red border and inline error message when quantity is below minimum
     - Proceed button is disabled until valid quantity is entered
     - Users can see their input and understand the validation requirement
     - Ensures economical production and sustainable business model
   - If sufficient credits: Instant batch creation, cards generated immediately, no Stripe redirect
   - If insufficient credits: Dialog shows warning with "Purchase Credits" button redirecting to `/cms/credits`
   - Uses `issue_card_batch_with_credits()` stored procedure
   - Credits consumed atomically with batch creation (transaction-safe)
9. **QR Code Download & Distribution**:
   - **Access**: Navigate to card > QR & Access tab
   - **Batch Selection**: Choose from paid batches with generated cards
   - **Download All QR Codes**: Bulk download as ZIP file containing:
     - All QR codes as high-quality PNG images (512x512px)
     - Organized in `qr_codes/` folder
     - File naming: `card_XXX_active.png` or `card_XXX_inactive.png`
     - README.txt with batch info, card list, URLs, and usage instructions
     - ZIP naming: `{cardName}_{batchName}_qr_codes_{date}.zip`
   - **Download CSV**: Export card list with IDs, status, and URLs for spreadsheet management
   - **Filter Support**: Download respects active/inactive filter settings
   - **Individual Actions**: Copy URL, download single QR code, open card preview
10. **Credit Management**: Monitor balance, view transaction history, purchase additional credits for batch issuance and translations.
11. **Print Requests**: After batch creation, optionally request physical card printing with shipping details.
12. **Analytics**: View engagement metrics per card/batch.

### Visitor (Mobile) Flow
1. **QR Scan**: Loads `PublicCardView` with issued card ID (or preview mode).
2. **Card Overview**: View card image/description, select language. **Actively maintained: en (English), zh-Hant (Traditional Chinese)**. Other 8 languages (zh-Hans, ja, ko, es, fr, ru, ar, th) have incomplete translations and fall back to English for missing keys.
3. **Content Navigation**: Browse top-level items, drill into details with sub-items.
   - **Automatic Translation Display**: If content is translated to the selected language, it's automatically displayed
   - **Fallback**: If translation unavailable, shows original language content
   - **Real-time Updates**: Language changes trigger immediate content reload with translated versions
4. **AI Interaction**:
   - **Chat Mode**: Text input or voice recording → Whisper STT → ChatGPT response → TTS audio.
   - **Realtime Mode**: Live voice call via WebRTC to OpenAI Realtime API, low-latency bidirectional audio.
   - Context: Combines card AI instruction, knowledge base, current content knowledge.
   - Language enforcement in prompts.

### Admin Flow
1. **User Management**: Verify businesses, assign roles ('admin' or 'cardIssuer').
2. **Credit Management**: Monitor all credit purchases, consumptions, and transactions. Adjust user credits for refunds or corrections.
   - **UI Pattern**: Follows Batch Management pattern (filters in table header, action buttons, dialogs)
   - **Action Buttons**: View Purchases, View Consumptions, View Transactions, Adjust Credits
   - **On-Demand Loading**: Dialog data fetched when opened, not preloaded
   - **Server-Side Operations**: All pagination, sorting, filtering done on server
   - **Search**: Debounced 500ms, searches by email or name
   - **Security**: Transaction locking prevents race conditions, negative balance prevented
3. **Batch Oversight**: Monitor issuances, credit consumption, print requests (statuses: pending, paid, shipped).
4. **Credit Statistics**: View system-wide credit metrics (circulation, revenue, consumption, pending).
5. **Audit Logs**: Track operations including credit transactions (via RPC logging).
6. **Content Moderation**: Review/approve cards.

### Payments & Credits
- **Credit System**: Users purchase credits upfront (1 credit = $1 USD) via Stripe checkout.
- **Credit Usage**:
  - **Batch Issuance**: 2 credits per card
  - **Translation** (NEW): 1 credit per language per card (covers all content: card + all items)
- **Batch Issuance**: 
  - **Credit-Based Flow** (Current): Consumes 2 credits per card, instant generation upon credit consumption
  - Uses `issue_card_batch_with_credits()` stored procedure which:
    - Checks credit balance via `check_credit_balance()`
    - Creates batch with `payment_method = 'credits'`, `payment_completed = true`
    - Consumes credits via `consume_credits_for_batch()`
    - Generates issued cards immediately
    - All operations atomic (rollback on failure)
  - UI Component: `CardIssuanceCheckout.vue` uses `useCreditStore().issueBatchWithCredits()`
  - No Stripe redirect during batch creation - credits must be purchased first
- **Translation System** (NEW):
  - **Credit Flow**: Consumes 1 credit per language, instant translation via GPT-4
  - **Parallel Translation**: All selected languages are translated **simultaneously** using `Promise.all()` for massive performance improvements (3-10x faster than sequential)
  - Uses `translate-card-content` Edge Function which:
    - Validates user authentication and card ownership
    - Checks credit balance via `check_credit_balance()`
    - **Translates all languages in parallel** (not sequential) - 5 languages complete in ~30s instead of ~150s
    - Calls GPT-4.1-nano with specialized prompts for museum/cultural content
    - Stores translations via `store_card_translations()` stored procedure
    - Consumes credits atomically with translation storage
    - Records audit trail in `translation_history` table
  - **Translation Storage**: JSONB columns in `cards` and `content_items` tables
  - **Freshness Tracking**: Automatic content hash updates trigger outdated status
  - **UI Component**: `TranslationManagement.vue` with `TranslationDialog.vue` for multi-step workflow
  - **Performance**: See `PARALLEL_TRANSLATION_IMPROVEMENT.md` for detailed performance metrics and implementation
- **Stripe Integration**: Credit purchase checkout, webhooks for confirmation, automatic refund handling.
  - **Webhook Security**: Stripe webhook signature verification in Deno requires `stripe.webhooks.constructEventAsync()` (async version) due to Deno's async crypto environment. The webhook function disables JWT verification (`verify_jwt = false` in `config.toml`) but enforces Stripe signature verification.
- **Credit Management**: Real-time balance tracking, transaction history, consumption reports (includes both batch issuance and translations).
  - **Admin Interface**: `AdminCreditManagement.vue` for admin oversight
    - Statistics cards: Total circulation, revenue, purchased, consumed
    - User table: Paginated list with search by email/name (server-side, debounced 500ms)
    - Action buttons per user: View Purchases (green), View Consumptions (blue), View Transactions (gray), Adjust Credits (orange)
    - Dialogs: On-demand data loading, show user info + paginated tables
    - Adjust credits: Supports positive (add) or negative (deduct) with reason, prevents negative balance
  - **Card Issuer Interface**: `CreditManagement.vue` for users to manage their own credits
    - Balance overview: Current, purchased, consumed with monthly stats
    - Purchase dialog: Select amount (10-10,000 credits), Stripe checkout integration
    - Transaction history: Tabs for all transactions, purchases, consumptions
  - **Security**: Transaction locking (`FOR UPDATE`) prevents race conditions, all operations logged
  - **Audit Trail**: Every credit change recorded in `credit_transactions` with before/after balances
- **Print Requests**: Optional physical cards, status tracking, contact fields.

### Internationalization
- **Active Languages**: Only **English (en)** and **Traditional Chinese (zh-Hant)** are actively maintained and fully translated.
- **Placeholder Languages**: Other language files (zh-Hans, ja, ko, es, fr, ru, ar, th) exist for future expansion but are NOT maintained. They contain partial/outdated translations and will fall back to English for missing keys.
- **Language Infrastructure**: 10 language files exist via vue-i18n, but only en and zh-Hant should be updated when adding new features.
- **Language Stores**: Mobile client uses `useMobileLanguageStore`, Dashboard uses `useDashboardLanguageStore` (separate stores for different contexts).
- **Dashboard Languages**: Dashboard language selector shows only **2 languages** (en, zh-Hant) for card issuers/admins. Simplified Chinese has been removed from dashboard to focus on actively maintained languages.
- **Mobile Client Languages**: Mobile language selector shows **all 10 languages** for visitors worldwide (en, zh-Hans, zh-Hant, ja, ko, th, es, fr, ru, ar).
- **Chinese Voice Selection** (Mobile Client Only):
  - **Text vs Voice Separation**: Chinese text script (Simplified/Traditional) is independent of voice dialect (Mandarin/Cantonese)
  - **Language Codes**: `zh-Hans` (Simplified), `zh-Hant` (Traditional) instead of legacy `zh-CN`, `zh-HK`
  - **Voice Preferences**: Users can select `mandarin` or `cantonese` voice via `ChineseVoiceSelector` component
  - **Smart Defaults**: Simplified defaults to Mandarin, Traditional defaults to Cantonese
  - **Voice-Aware Language Codes**: `getVoiceAwareLanguageCode()` returns combined codes like `zh-Hans-mandarin` or `zh-Hant-cantonese` for AI systems
  - **AI Integration**: Voice preference affects both TTS (Text-to-Speech) and Realtime API, enforced through system instructions
  - **Components**: `ChineseVoiceSelector.vue` in `MobileHeader.vue`, only visible when Chinese language selected
  - **Important**: `zh-Hans` remains a placeholder language with incomplete translations. While it's used for text script differentiation in Chinese voice selection, Dashboard UI for Simplified Chinese users will fall back to English for missing keys. This is expected behavior.
  - See `CHINESE_VOICE_SELECTION_FEATURE.md` for full implementation details
- **Pluralization**: Use pipe syntax (e.g., `{count} card | {count} cards`). **Important**: Use format `Singular text | Plural text` without parentheses. In Composition API mode (`legacy: false`), parentheses around pluralized sections will break the parser.
- **RTL Support**: Arabic RTL CSS exists but translations are incomplete/not maintained.
- **Console Warnings**: i18n fallback warnings for placeholder languages (zh-Hans, ko, ja, etc.) are expected and can be ignored. These occur when Dashboard UI elements don't have translations in placeholder locales.

## Deployment

**📋 For complete deployment instructions, see [DEPLOYMENT_COMPLETE_GUIDE.md](DEPLOYMENT_COMPLETE_GUIDE.md)**

The deployment guide includes:
- Environment variables configuration (.env setup)
- Supabase bucket setup (Storage configuration)
- Authentication configuration (password reset redirect URLs)
- Edge Functions deployment (secrets + deployment)
- Database SQL deployment (schema, stored procedures, triggers, policies)
- Post-deployment verification checklist
- Monitoring and troubleshooting

### Quick Reference

**Frontend**:
1. Build: `npm run build:production`
2. Deploy `dist/` to static host (Vercel, Netlify, etc.)
3. Set env vars: `VITE_SUPABASE_URL`, `VITE_SUPABASE_ANON_KEY`, `VITE_STRIPE_PUBLISHABLE_KEY`, etc.

**Backend (Supabase)**:
1. **Database** (execute in Supabase Dashboard SQL Editor):
   - Combine stored procedures: `./scripts/combine-storeproc.sh`
   - Execute in order: `schema.sql` → `all_stored_procedures.sql` → `policy.sql` → `triggers.sql`

2. **Edge Functions**:
   - Set secrets: `./scripts/setup-production-secrets.sh`
   - Deploy: `./scripts/deploy-edge-functions.sh`
   - Required secrets: `OPENAI_API_KEY`, `STRIPE_SECRET_KEY`, `OPENAI_REALTIME_MODEL`, `STRIPE_WEBHOOK_SECRET`

3. **Storage**: Create public bucket: `userfiles` (app organizes files in folders: `{user_id}/card-images/` and `{user_id}/content-images/`)

4. **Authentication**: 
   - Configure redirect URLs in Supabase Dashboard > Authentication > URL Configuration
   - Add `/reset-password` to whitelist for password reset functionality

**Deployment Order**: Database → Secrets → Edge Functions → Storage → Frontend → Stripe Webhooks

## Notes and Best Practices

- **Database Access**: **NEVER** use `supabase.from()`. All database operations are handled via `supabase.rpc()` calling stored procedures (e.g., `get_public_card_content`, `create_card`, `update_content_item`, `get_card_translation_status`, `store_card_translations`). This pattern ensures security and centralizes business logic. Direct table access is prohibited.
- **Database Updates**: When updating stored procedures, edit source files in `sql/storeproc/`, run `./scripts/combine-storeproc.sh`, then manually execute the generated `sql/all_stored_procedures.sql` in Supabase Dashboard. Do NOT write migration scripts - user handles manual deployment.

### 🔐 Stored Procedure Security Model

**Folder Structure**: Separate folders enforce security patterns
- `sql/storeproc/client-side/` - Called from frontend or Edge Functions with user JWT
- `sql/storeproc/server-side/` - Called from Edge Functions with SERVICE_ROLE_KEY

#### Client-Side Pattern (`client-side/` folder)
**When to use**: Frontend calls, Edge Function uses ANON_KEY + User JWT
```sql
CREATE OR REPLACE FUNCTION my_client_function(p_card_id UUID)
RETURNS JSONB SECURITY DEFINER AS $$
DECLARE
    v_user_id UUID := auth.uid();  -- ✅ Gets user from JWT
BEGIN
    IF v_user_id IS NULL THEN RAISE EXCEPTION 'Not authenticated'; END IF;
    -- Verify ownership
    IF NOT EXISTS (SELECT 1 FROM cards WHERE id = p_card_id AND user_id = v_user_id) THEN
        RAISE EXCEPTION 'Unauthorized';
    END IF;
    -- Business logic...
END;
$$ LANGUAGE plpgsql;
GRANT EXECUTE ON FUNCTION my_client_function(UUID) TO authenticated;
```

**Characteristics**:
- ✅ Uses `auth.uid()` to get user from JWT
- ✅ PostgreSQL executes as `authenticated` role
- ✅ GRANT TO authenticated
- ✅ RLS policies apply
- ❌ Never accept `p_user_id` parameter (security risk!)

#### Server-Side Pattern (`server-side/` folder)
**When to use**: Edge Function uses SERVICE_ROLE_KEY, webhooks, privileged operations
```sql
CREATE OR REPLACE FUNCTION my_server_function(
    p_user_id UUID,  -- ✅ Explicit parameter (REQUIRED!)
    p_card_id UUID
)
RETURNS JSONB SECURITY DEFINER AS $$
DECLARE
    v_card_owner UUID;
BEGIN
    -- Validate user exists
    IF NOT EXISTS (SELECT 1 FROM auth.users WHERE id = p_user_id) THEN
        RAISE EXCEPTION 'Invalid user ID';
    END IF;
    -- Verify ownership against parameter
    SELECT user_id INTO v_card_owner FROM cards WHERE id = p_card_id;
    IF v_card_owner != p_user_id THEN RAISE EXCEPTION 'Unauthorized'; END IF;
    -- Privileged business logic...
END;
$$ LANGUAGE plpgsql;
GRANT EXECUTE ON FUNCTION my_server_function(UUID, UUID) TO service_role;
```

**Characteristics**:
- ✅ Accepts explicit `p_user_id UUID` parameter
- ✅ PostgreSQL executes as `service_role` role
- ✅ GRANT TO service_role ONLY
- ✅ Can bypass RLS with SECURITY DEFINER
- ❌ `auth.uid()` returns NULL (no JWT context)
- ✅ Examples: `store_card_translations`, `complete_credit_purchase`

**Edge Function Pattern for Server-Side**:
```typescript
// Edge Function using SERVICE_ROLE_KEY
const supabaseAdmin = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
// Validate JWT manually
const token = req.headers.get('Authorization')?.replace('Bearer ', '');
const { data: { user }, error } = await supabaseAdmin.auth.getUser(token);
if (error || !user) throw new Error('Unauthorized');
// Call with explicit user ID
await supabaseAdmin.rpc('my_server_function', {
  p_user_id: user.id,  // Explicit parameter
  p_card_id: cardId
});
```

**Security Rules**:
- Client-side procedures: NEVER accept `p_user_id` parameter, ALWAYS use `auth.uid()`
- Server-side procedures: ALWAYS accept `p_user_id` parameter, NEVER use `auth.uid()`
- Folder location immediately indicates security pattern
- See: `sql/storeproc/client-side/README.md` and `sql/storeproc/server-side/README.md`

#### Dual-Use Pattern (Exception)
Some credit management functions in `client-side/credit_management.sql` use a **dual-use pattern** with `COALESCE(p_user_id, auth.uid())`:
- Can be called from **frontend** (without `p_user_id`, uses `auth.uid()`)
- Can be called from **Edge Functions** (with explicit `p_user_id` parameter)
- Have `GRANT TO authenticated, service_role` for both use cases

**Dual-use functions**:
- `check_credit_balance()` - Called by frontend and `translate-card-content`
- `create_credit_purchase_record()` - Called by frontend and `create-credit-checkout-session`
- `consume_credits()` - Called by frontend and server-side `store_card_translations()`

**Pattern**:
```sql
CREATE OR REPLACE FUNCTION check_credit_balance(
    p_required_credits DECIMAL,
    p_user_id UUID DEFAULT NULL  -- Optional for dual-use
)
RETURNS DECIMAL AS $$
DECLARE
    v_user_id UUID;
BEGIN
    v_user_id := COALESCE(p_user_id, auth.uid());  -- Dual-use pattern
    -- Rest of function...
END;
$$ LANGUAGE plpgsql;
GRANT EXECUTE TO authenticated, service_role;  -- Both roles
```

**When to use**: Only for utility functions that genuinely need to work in both contexts. Prefer pure client-side or server-side patterns for clarity.

#### Stored Procedure Requirements ⚠️

**CRITICAL**: Every stored procedure MUST have explicit GRANT statements:

```sql
-- Client-side functions
GRANT EXECUTE ON FUNCTION my_function(...) TO authenticated;

-- Server-side functions
GRANT EXECUTE ON FUNCTION my_function(...) TO service_role;

-- Dual-use functions
GRANT EXECUTE ON FUNCTION my_function(...) TO authenticated, service_role;
```

**Common Errors**:
- ❌ Missing GRANT → "permission denied for function"
- ❌ Wrong role in GRANT → Function not callable from intended context
- ❌ Wrong function signature in GRANT → Grant doesn't apply

**Verification**: After deploying stored procedures, verify grants:
```sql
SELECT 
    p.proname as function_name,
    array_agg(pr.rolname) as granted_to
FROM pg_proc p
LEFT JOIN pg_proc_acl_explode(p.proacl) acl ON true
LEFT JOIN pg_roles pr ON acl.grantee = pr.oid
WHERE p.proname = 'your_function_name'
GROUP BY p.proname;
```

**log_operation Usage**: When logging operations, use single text parameter:
```sql
-- ✅ CORRECT
PERFORM log_operation('Created card: ' || p_name);
PERFORM log_operation(format('Consumed %s credits', p_amount));

-- ❌ WRONG (function only accepts 1 parameter)
PERFORM log_operation(user_id, 'action', 'table', record_id, metadata);
```

- **Role Handling**: Supabase Auth with custom roles stored in `raw_user_meta_data.role`. Router guards check 'admin' vs 'cardIssuer'. After role changes, users must refresh their session to sync metadata.
- **Image Handling**: All cards use 2:3 aspect ratio. Images cropped via `vue-advanced-cropper`. Both original and cropped versions stored in Supabase Storage buckets. Crop parameters saved to enable re-cropping.
- **Export/Import**: Cards can be exported to Excel with embedded images (not URLs). Export uses original images with crop parameters in hidden columns. Import applies crop parameters to regenerate cropped versions. Uses ExcelJS for robust Excel handling. Parent-child relationships preserved via cell references (e.g., A5 for parent at row 5). Validation includes word count limits: AI instruction (100 words), card knowledge base (2000 words), content knowledge base (500 words). **COMPLETE DATA PRESERVATION**: Exports include `original_language`, `translations` JSONB, and `content_hash` in hidden Excel columns, ensuring 100% data integrity. **1-STEP IMPORT**: Translations and content hashes preserved automatically during import via enhanced stored procedures (`create_card`, `create_content_item`) that accept optional `p_content_hash` and `p_translations` parameters. Hash triggers skip calculation when hash provided (import), ensuring translations immediately show "Up to Date" status without recalculation.
- **AI Costs**: Use `gpt-4o-mini` for chat mode, `gpt-realtime-mini-2025-10-06` for voice mode (realtime), `gpt-4.1-nano-2025-04-14` for translations. Implement safeguards: session limits, inactivity timeouts, daily caps.
- **Translation Management**: 
  - **Storage**: Use JSONB columns for storing translations (flexible, no schema changes for new languages)
  - **Original Language**: Users select original language during card creation (`original_language` field, defaults to 'en'). This field is used by AI translation system and displayed in UI.
  - **Content Hash Tracking**: Automatically detects when originals become outdated
    - **Smart Triggers**: The `update_card_content_hash()` and `update_content_item_content_hash()` trigger functions calculate hash on INSERT only if NULL, allowing import to preserve original hashes. On UPDATE, recalculates only if content changed AND hash wasn't manually updated.
    - **Import Preservation**: During import, hash is provided via `p_content_hash` parameter, trigger skips calculation, ensuring perfect translation freshness after import.
  - **Translation Process**:
    - All translation operations are atomic with credit consumption (rollback on failure)
    - **Credit Confirmation**: Uses `CreditConfirmationDialog` to confirm credit usage before translation (1 credit per language)
    - GPT-4.1-nano prompts are specialized for museum/cultural/tourism content with markdown preservation
    - Translation freshness is checked by comparing stored content_hash with current content_hash
  - **Status Indicators**: 
    - **Up to Date**: Translation matches current content (green badge, cannot re-translate)
    - **Outdated**: Content changed since last translation (amber badge, update recommended)
    - **Not Translated**: No translation exists yet (gray, available for translation)
  - **Translation Preview**: 
    - Card view and content view have language dropdowns to preview translated content
    - Displays translated card name, description, content item name, and content
    - Falls back to original language if translation unavailable
    - Updated stored procedures (`get_user_cards`, `get_card_content_items`, `get_content_item_by_id`) return translation data
  - **Mobile Client**: Automatically displays translated content when available, falls back to original
  - **State Management**: Translation store (`useTranslationStore`) manages state for status, history, and operations
- **Error Handling**: Use PrimeVue Toast (`useToast`) for user feedback. Log errors to browser console and operations log (via stored procedures).
- **Component Size**: Keep <400 lines; extract to composables.
- **i18n**: Pipe syntax for plurals, no ICU. **Always update both locales/en.json AND locales/zh-Hant.json when adding new keys**. Other language files are placeholders and not maintained.
- **Markdown**: Render with `marked` library using `@/utils/markdownRenderer`. All links automatically open in new tabs with `target="_blank"` and `rel="noopener noreferrer"` for security. Use `renderMarkdown(text)` utility function instead of calling `marked.parse()` directly.
- **Mobile Optimization**: Responsive Tailwind, touch-friendly, PWA-ready.
- **Design Consistency**: AI Assistant input bar follows compact, modern design principles: 40px buttons (36px on mobile), 1.5px borders, 10px radius, subtle shadows and animations for professional polish. See `INPUT_BAR_DESIGN_IMPROVEMENT.md` for full design system.
- **Reusable Dialogs**: For common confirmation patterns (credit usage, destructive actions), create reusable components with props for customization. Example: `CreditConfirmationDialog.vue` with `creditsToConsume`, `currentBalance`, `itemCount` props, and `confirm`/`cancel` events. See `src/components/README_CreditConfirmationDialog.md` for API reference.
- **URL Parameters for State**: Use URL query parameters to maintain application state for shareable/bookmarkable views. Pattern: Read from `route.query` on mount, emit events to parent on change, parent updates URL via `router.replace()`. Example: `batchId` parameter in Access tab (`/cms/mycards?cardId=...&tab=access&batchId=...`) enables direct linking to specific batch QR codes.
- **Navigation Consistency**: All "view" actions for the same resource should navigate to the same destination. Example: Batch "View Cards" buttons (table, success dialog, info button) all route to `/cms/mycards?cardId=...&tab=access&batchId=...` for consistent UX.
- **Button Design Consistency**: Use consistent visual language for action buttons: gradient (primary actions), filled (status indicators), blue outlined (information/navigation), gray outlined (secondary). Avoid mixing styles unless intentional visual hierarchy is needed.
- **Admin DataTable Design Pattern**: All admin tables should follow this consistent structure for visual harmony:
  ```vue
  <div class="bg-white rounded-xl shadow-lg border border-slate-200 overflow-hidden">
    <div class="px-6 py-4 border-b border-slate-200">
      <h2 class="text-lg font-semibold text-slate-900">Title</h2>
      <p class="text-sm text-slate-600 mt-1">Description</p>
    </div>
    <div class="p-6">
      <DataTable
        showGridlines
        responsiveLayout="scroll"
        :rows="10"
        :rowsPerPageOptions="[10, 20, 50]"
      >
        <!-- Column definitions with style="min-width: XXXpx" -->
        <!-- Empty state with py-12, text-6xl icon -->
        <!-- Loading state with ProgressSpinner 50×50px -->
      </DataTable>
    </div>
  </div>
  ```
  Key elements: `shadow-lg` (not shadow-soft), padding wrapper (`p-6`) around table, no striped rows, consistent empty/loading states, proper column min-widths.
- **Edge Functions Authentication**: 
  - **Client-side calls**: Always use the user's JWT token from `supabase.auth.getSession()`, never the anon key:
    ```typescript
    const { data: { session } } = await supabase.auth.getSession()
    const token = session?.access_token
    fetch(`${supabaseUrl}/functions/v1/my-function`, {
      headers: { 'Authorization': `Bearer ${token}` }
    })
    ```
  - **Edge Function validation**: When Edge Functions need to validate user authentication:
    - Use service role client: `createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)`
    - Extract JWT token from Authorization header: `req.headers.get('Authorization').replace('Bearer ', '')`
    - Validate token: `supabaseAdmin.auth.getUser(token)` - this returns user info from the JWT
    - Pass `user.id` explicitly to stored procedures when using service role (since `auth.uid()` returns NULL with service role)
    - Stored procedures should accept optional `p_user_id` parameter: `COALESCE(p_user_id, auth.uid())`
- **Common Issues**:
  - Role mismatches: Refresh session to sync DB metadata.
  - Audio permissions: Handle gracefully in WebRTC/STT.
  - CORS: Edge functions handle via `_shared/cors.ts`.
  - Large images: Compress with `browser-image-compression`.
  - **Deno Stripe Webhooks**: Always use `stripe.webhooks.constructEventAsync()` (async version) for signature verification in Deno Edge Functions due to async crypto environment. Using the sync `constructEvent()` will fail.
  - **Edge Function 401 Errors**: If Edge Functions return 401 Unauthorized, check that JWT tokens are being properly validated. Don't use `getUser()` without parameters - always pass the token explicitly when using service role client.
  - **Edge Function Connection Closed (ERR_CONNECTION_CLOSED)**: If Edge Function calls fail with connection closed error, verify you're using the user's JWT token (`session?.access_token`) in the Authorization header, NOT the anon key. The anon key should only be used for public/unauthenticated endpoints.
  - **Edge Function Helper Functions**: In Deno Edge Functions, helper functions defined with `const` (function expressions) are not hoisted. Always define helper functions **before** they are called, or use function declarations (`function name() {}`) which are hoisted.
  - **Translation Shows "Outdated" Immediately**: If translations show as outdated right after creation, this is due to NULL `content_hash` values. The fix is to ensure triggers calculate hash on INSERT, not just UPDATE. See `TRANSLATION_FRESHNESS_BUG_FIX.md` and deploy `DEPLOY_TRANSLATION_HASH_FIX.sql`. Cards translated before the fix will need re-translation.
  - **Translation Button Pluralization**: If button text displays literally (with pipe character), check pluralization format. Use `Singular | Plural` format without parentheses. Example: `Translate {count} Language | Translate {count} Languages` (correct) vs `Translate ({count} language | {count} languages)` (incorrect - breaks parser in Composition API mode).
  - **Translation Preview Not Showing**: If language dropdown doesn't appear in CardView or ContentView, ensure stored procedures return translation fields. Update `get_user_cards`, `get_card_content_items`, and `get_content_item_by_id` to include `translations`, `original_language`, `content_hash`, and `last_content_update` in SELECT and RETURNS TABLE.
  - **Export/Import Translation Preservation**: When exporting/importing cards, translations ARE preserved in hidden Excel columns. However, after import, translations may appear "Outdated" due to content hash mismatch. **Solution deployed**: Import process now automatically calls `recalculate_all_translation_hashes()` immediately after creating the card and all content items. This synchronizes the embedded translation hashes (from the old exported card) with the newly created card's content hashes, ensuring translations show "Up to Date" after import. See `CardBulkImport.vue` line ~1134 and `sql/storeproc/client-side/12_translation_management.sql` for implementation.
  - **Translations Not Showing "Outdated" After Content Update**: If you update card content (name/description) or content item content but translations don't show as "Outdated", the database triggers are missing or not deployed. These triggers (`trigger_update_card_content_hash` and `trigger_update_content_item_content_hash`) automatically update the `content_hash` field when content changes, which is essential for translation freshness detection. **Solution**: Deploy `sql/triggers.sql` to your database (triggers are already correctly defined in source files). Verify triggers exist with `SELECT tgname FROM pg_trigger WHERE tgname LIKE '%content_hash%';` Frontend refresh mechanism is already in place in `CardView.vue` line 371-372. See `DEPLOY_TRANSLATION_FIXES.md` for deployment guide.
  - **Outdated Languages Not Retranslating**: If you select outdated languages for re-translation but the edge function doesn't process them, this was a bug in the edge function logic. **Fixed**: Edge function now correctly filters languages, charges only for languages actually translated, and returns early if all selected languages are up-to-date. Deploy fix: `npx supabase functions deploy translate-card-content`. See `TRANSLATION_OUTDATED_RETRANSLATION_FIX.md` for details.
  - **Legacy Batch Payment vs Credit System**: 
    - **Current System** (Recommended): Credit-based batch issuance. Users purchase credits via `/cms/credits` → Use credits to create batches instantly via `CardIssuanceCheckout.vue` → No Stripe checkout during batch creation
    - **Legacy System** (Deprecated): Direct batch payment via `create-checkout-session` Edge Function. Still functional for backward compatibility but not recommended for new implementations
    - Migration: `CardIssuanceCheckout.vue` has been fully migrated to use `useCreditStore().issueBatchWithCredits()` instead of `createCheckoutSession()`
  - **Credit Adjustment Errors**: If credit adjustment fails, check for: (1) User has `user_credits` record (auto-created), (2) Adjustment doesn't result in negative balance, (3) Admin has proper role in metadata, (4) Amount is not zero.
  - **Admin Dialog Data**: When opening dialogs (purchases, consumptions, transactions), previous user's data may flash briefly. This is normal - new data loads on-demand when dialog opens.
  - **Search Performance**: For user bases >10,000, consider implementing full-text search (tsvector) instead of LIKE queries for better performance.
  - **Stored Procedure Deployment Errors**:
    - **Missing GRANT statements**: Always add GRANT statements after creating functions. Without them, functions cannot be called and will fail with "permission denied". Run verification query to check grants after deployment.
    - **Wrong function names in GRANT**: Ensure GRANT statement matches exact function name (e.g., `get_credit_statistics` not `get_user_credit_stats`). Check actual function names with `SELECT proname FROM pg_proc WHERE proname LIKE '%credit%';`
    - **Wrong log_operation signature**: `log_operation()` accepts only 1 TEXT parameter. Use `format()` to create descriptive log messages. Common mistake: passing multiple parameters like `log_operation(user_id, action, table, record_id, metadata)` - this will fail.
    - **After deployment checklist**: (1) Verify GRANT statements applied, (2) Test function calls from frontend, (3) Test function calls from Edge Functions (if dual-use), (4) Check Supabase logs for errors.
  - **Batch Issuance Credit Check Error**: If batch creation fails with "argument of NOT must be type boolean, not type numeric", check that `check_credit_balance()` is used correctly. This function returns DECIMAL (the actual balance), not BOOLEAN. Correct usage: `v_balance := check_credit_balance(required); IF v_balance < required THEN ...` not `IF NOT check_credit_balance(required) THEN ...`
  - **AI Chat Input Bar Disappearing**: If the input bar disappears when chat messages overflow, ensure modal slot content has proper flex constraints. Wrap slot in a container with `flex: 1`, `overflow: hidden`, and `min-height: 0` (critical for nested flex layouts to allow shrinking). See `AI_CHAT_INPUT_BAR_FIX.md` for detailed explanation.
  - **Realtime API CORS Error (ERR_CONNECTION_CLOSED)**: If Realtime voice calls fail with CORS error "No 'Access-Control-Allow-Origin' header", this is because the `model` parameter is missing from the API endpoint URL. OpenAI's Realtime API requires `?model=xxx` when using ephemeral tokens. Fix: Add `VITE_OPENAI_REALTIME_MODEL=gpt-realtime-mini-2025-10-06` to `.env.local` and ensure it matches the Supabase Edge Function's `OPENAI_REALTIME_MODEL` secret. Both frontend and backend must use the same model. See `REALTIME_CORS_FIX.md` for full details.
  - **Password Reset Not Working**: If password reset emails don't redirect users to the reset page, the issue is missing Supabase redirect URL configuration. Fix: (1) Add `PASSWORD_RECOVERY` event handler in auth store to redirect to `/reset-password`, (2) Configure redirect URLs in Supabase Dashboard → Authentication → URL Configuration → Add `http://localhost:5173/reset-password` (dev) and `https://your-domain.com/reset-password` (prod) to whitelist. The auth store sends reset emails with `redirectTo: ${window.location.origin}/reset-password` but Supabase won't redirect unless the URL is whitelisted. See `PASSWORD_RESET_FIX.md` for full details.
- **Testing**: Use local Supabase for dev, preview mode for unactivated cards.
- **Security**: RLS policies enforce public read-only for cards, auth for dashboard.
- **Performance**: Lazy-load routes, virtual scrolling for lists, WebRTC for low-latency AI.

For additional technical details, see files in `docs_archive/` (all implementation docs have been archived there).

## Consolidated documentation (scanned)

I scanned the repository's markdown documents and consolidated the most important operational and architecture notes below. If you want, I can archive the remaining files into `docs_archive/` (or delete them) — I will wait for your confirmation before moving or deleting files.

- **Real-time audio mode (REALTIME_MODE_FINAL_SUMMARY.md)**
  - Status: Implementation complete and deployed.
  - Key points: full WebRTC integration, ephemeral tokens, direct OpenAI connections (optional relay), UI/UX details (waveform, live transcript), performance metrics, testing checklist, and production readiness notes.
  - Action: Included core architecture, user flow, and deployment notes above (AI Infrastructure, Realtime Mode).

- **OpenAI Realy Server & setup (OPENAI_RELAY_IMPLEMENTATION_SUMMARY.md / OPENAI_RELAY_SERVER_SETUP.md)**
  - Purpose: Relay server to proxy OpenAI Realtime API for regions where direct access is blocked.
  - Contents: relay server architecture, deployment options (Railway, DigitalOcean, AWS, Cloud Run), security and scaling recommendations, testing steps, and environment configuration (VITE_OPENAI_RELAY_URL).
  - Action: Added relay overview to AI Infrastructure section. Keep `openai-relay-server/` directory (contains full server docs) if you intend to support blocked regions; otherwise archive it.

- **AI Assistant — 10 languages (AI_ASSISTANT_10_LANGUAGES.md)**
  - Purpose: Full design and implementation notes for supporting 10 languages (text + audio) including welcome messages, language selection, testing plan, and cost estimates.
  - Action: Core language list and welcome message guidance were integrated into the i18n and AI notes above.

- **Edge Functions configuration (EDGE_FUNCTIONS_CONFIG.md)**
  - Purpose: Centralized environment variable guidance for all Supabase Edge Functions (chat-with-audio, generate-tts-audio, create-checkout-session, etc.).
  - Action: Relevant secrets and deployment checklist have been summarized into the Setup & Deployment and Environment Variables sections above.

## Landing Page Design

The landing page (`src/views/Public/LandingPage.vue`) has been completely redesigned with comprehensive marketing content while maintaining perfect design consistency with the existing component system. **The landing page now uses the UnifiedHeader component** (`src/components/Layout/UnifiedHeader.vue`), which is shared with the dashboard to provide consistent branding and user experience across the platform.

**Design Principles:**
- **Color Consistency**: Uses the same blue-purple-slate gradient system as dashboard components
- **Typography**: Consistent font sizing (`text-3xl`, `text-4xl`, `text-5xl`) and weights (`font-bold`, `font-black`)
- **Shadows**: Uses `shadow-lg`, `shadow-xl`, `shadow-2xl` matching the app's shadow system
- **Border Radius**: Consistent `rounded-xl`, `rounded-2xl`, `rounded-3xl` throughout
- **Spacing**: Standard section padding (`py-20`, `max-w-7xl mx-auto px-4 sm:px-6 lg:px-8`)

**Sections Included:**
1. **Hero Section**: Full-width with parallax animations, gradient background, dual CTAs
2. **About Section**: Company introduction with icon grid for application scenarios
3. **Demo Section**: Interactive QR card demo (kept from original design for user experience testing)
4. **How It Works**: 4-step visitor journey with connecting lines and icons
5. **Key Features**: 6 feature cards highlighting platform capabilities
6. **Versatile Applications**: Carousel showing 8 use cases (museums, trade shows, hotels, etc.)
7. **Benefits Section**: Two-column layout for venue and visitor benefits
8. **Sustainability Impact**: Environmental metrics comparison (traditional vs CardStudio)
9. **Pricing Section**: Transparent $2/card pricing with feature checklist
10. **Collaboration Models**: 3 partnership options (Client, Regional Partner, Software License)
11. **FAQ Section**: Accordion-style Q&A addressing common questions
12. **Contact Section**: Multi-channel contact info with clear CTAs
13. **Footer**: Brand info, quick links, contact details

**Key Features:**
- Fully responsive design (mobile-first approach)
- Smooth scroll animations and transitions
- Interactive elements (hover effects, carousels, accordions)
- Consistent gradient CTAs matching existing buttons
- Environment variable support for contact info and demo card configuration
- Backup file created at `LandingPage.backup.vue` for safety

**Environment Variables Used:**
- `VITE_SAMPLE_QR_URL`: Demo card QR code URL
- `VITE_DEMO_CARD_TITLE`: Demo card title
- `VITE_DEMO_CARD_SUBTITLE`: Demo card subtitle
- `VITE_DEFAULT_CARD_IMAGE_URL`: Demo card image
- `VITE_CONTACT_EMAIL`: Contact email address
- `VITE_CONTACT_WHATSAPP_URL`: WhatsApp chat link
- `VITE_CONTACT_PHONE`: Contact phone number (displayed in WhatsApp section)
- `VITE_BATCH_MIN_QUANTITY`: Minimum number of cards per batch (default: 100)

## Archived files (moved to `docs_archive/`)

I archived a curated set of implementation and deployment documents into `docs_archive/` to reduce clutter while preserving full content and git history. Originals were removed from the repository root and the archived copies are committed under `docs_archive/`.

Archived files (now in `docs_archive/`):

- `REALTIME_AUDIO_FULL_IMPLEMENTATION.md`
- `AI_STREAMING_IMPLEMENTATION.md`
- `AI_TEXT_TTS_IMPLEMENTATION.md`
- `AI_ASSISTANT_DEPLOYMENT_GUIDE.md`
- `AI_ASSISTANT_IMPLEMENTATION_COMPLETE.md`
- `AI_ASSISTANT_REVAMP.md`
- `AI_ASSISTANT_10_LANGUAGES.md`
- `EDGE_FUNCTIONS_CONFIG.md`
- `OPENAI_RELAY_IMPLEMENTATION_SUMMARY.md`
- `OPENAI_RELAY_SERVER_SETUP.md`
- `STREAMING_QUICK_START.md`

All implementation documentation has been consolidated and archived for reference.

## Deep archive summaries (high-level highlights extracted from `docs_archive/`)

- **Realtime & Relay**:
  - Realtime mode uses WebRTC + ephemeral tokens for low-latency voice (model: `gpt-realtime-mini-2025-10-06`). Direct WebRTC connection is used in production. Set `OPENAI_REALTIME_MODEL` in Supabase secrets. See `docs_archive/REALTIME_AUDIO_FULL_IMPLEMENTATION.md` for implementation details.

- **AI Assistant Modes**:
  - Two main modes: Chat Completion (text-first, cheaper) and Realtime (voice, low-latency). Recommended production flow: Text + TTS (STT → text generation → TTS) for cost/UX, plus text streaming (SSE) for faster perceived responses. See `docs_archive/AI_TEXT_TTS_IMPLEMENTATION.md` and `AI_STREAMING_IMPLEMENTATION.md`.

- **Edge Functions & Secrets**:
  - Central config in `supabase/config.toml` for local dev; use `supabase secrets set` in production. Required secrets: `OPENAI_API_KEY`, `STRIPE_SECRET_KEY`. Optional overrides: `OPENAI_AUDIO_MODEL`, `OPENAI_TTS_VOICE`, `OPENAI_MAX_TOKENS`, `OPENAI_AUDIO_FORMAT`. See `docs_archive/EDGE_FUNCTIONS_CONFIG.md`.

- **Internationalization (i18n)**:
  - **Active Languages**: Only `en` (English) and `zh-Hant` (Traditional Chinese) are actively maintained. Other 8 language files exist as placeholders for future expansion but contain incomplete translations.
  - Platform has 10 language options: `en`, `zh-Hant`, `zh-Hans`, `ja`, `ko`, `es`, `fr`, `ru`, `ar`, `th`. AI assistant provides localized welcome messages for active languages. Keep mobile and dashboard language stores separate (`useMobileLanguageStore` and `useDashboardLanguageStore`). See `docs_archive/AI_ASSISTANT_10_LANGUAGES.md`.

- **Deployment & Ops**:
  - Frontend: `npm run build` → deploy `dist/`. Edge Functions: `npx supabase functions deploy`. Always set secrets before deploy, add monitoring (health, logs, metrics), run browser compatibility tests (Safari/iOS). See `docs_archive/AI_ASSISTANT_DEPLOYMENT_GUIDE.md` and `docs_archive/REALTIME_AUDIO_FULL_IMPLEMENTATION.md`.

- **Cost & Safeguards**:
  - Realtime voice sessions are costlier (~$0.90 per 5-min session) than chat/text. Implement session timeouts, daily caps, and cost-monitoring; default to Text+TTS for public usage. See archived cost analysis files.

- **Security & Best Practices**:
  - Use ephemeral tokens for realtime, rotate API keys, never commit secrets, enforce RLS and CORS, and use HTTPS/WSS in production. See `docs_archive/EDGE_FUNCTIONS_CONFIG.md` and relay docs.

- **Testing & Compatibility**:
  - Test on Chrome, Firefox, Safari (desktop + iOS) and mobile browsers; verify microphone permissions, audio autoplay policies, and graceful fallbacks (text-only mode).

- **Where to find full details**:
  - All archived docs are in `docs_archive/`. Use the file names listed earlier in this document to jump to full guides, checklists, scripts, and config examples.

---

Next steps (pick one):
- A: Archive additional files (specify filenames or patterns).
- B: Restore specific archived files back to repo root (specify filenames).
- C: Finalize and run a quick linter / smoke-check.